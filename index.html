<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tetris js</title>
</head>

<body>

    <canvas id="canvas"></canvas>
    <script>

        // Obtener referencia al canvas y al contexto de dibujo
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Constantes
        const board_width = 10;
        const board_height = 20;
        const piece_shapes = [
            // I
            {
                shape: [[1, 1, 1, 1]],
                color: 'red',
            },
            // J
            {
                shape: [
                    [0, 0, 2],
                    [2, 2, 2]
                ],
                color: 'white',
            },
            // L
            {
                shape: [
                    [3, 0, 0],
                    [3, 3, 3]
                ],
                color: 'magenta',
            },
            // O
            {
                shape: [
                    [4, 4],
                    [4, 4]
                ],
                color: 'blue',
            },
            // S
            {
                shape: [
                    [0, 5, 5],
                    [5, 5, 0]
                ],
                color: 'green',
            },
            // T
            {
                shape: [
                    [0, 6, 0],
                    [6, 6, 6]
                ],
                color: 'brown',
            },
            // Z
            {
                shape: [
                    [7, 7, 0],
                    [0, 7, 7]
                ],
                color: 'cyan',
            }
        ];


        // Variables
        const board = [];
        let currentPiece = getRandomPiece(null);
        let currentX = 0;
        let currentY = 0;
        let score = 0;
        let lines = 0;
        let gameOver = false;
        let down_time = 1000; // 1000ms = 1 segundo
        for (let i = 0; i < board_height; i++) {
            board[i] = [];
            for (let j = 0; j < board_width; j++) {
                board[i][j] = 0;
            }
        }

        // Definir tamaño del canvas
        canvas.width = 100;
        canvas.height = 200;

        // Dibujar el tablero
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Definir tamaño de las celdas y bordes
        const border_width = 0;
        const cell_size = (canvas.width / board_width);
        const cell_size_x = (canvas.width / board_width);
        const cell_size_y = (canvas.height / board_height);

        // Dibujar las celdas del tablero
        function draw_board() {
            ctx.fillStyle = '#000'; // dibuja el fondo del tablero
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < board_height; y++) {
                for (let x = 0; x < board_width; x++) {
                    // Calcular la posición en píxeles de la celda
                    const xPos = x * cell_size_x;
                    const yPos = y * cell_size_y;
                    // Dibujar la celda (si está ocupada)
                    if (board[y][x]) {
                        // Dibujar el borde de la celda
                        ctx.fillStyle = '#ccc';
                        ctx.fillRect(xPos, yPos, cell_size_x, cell_size_y);
                        // Dibujar la celda
                        ctx.fillStyle = '#aaa';
                        ctx.fillRect(xPos + border_width, yPos + border_width, cell_size_x - border_width * 2, cell_size_y - border_width * 2);
                    }
                }
            }
        }

        function getRandomPiece(currentPiece) {
            let newPiece = null;

            if (currentPiece === null) {
                currentPiece = {
                    shape: [],
                    color: '',
                };
            }

            while (newPiece === null || JSON.stringify(newPiece.shape) === JSON.stringify(currentPiece.shape)) {
                // Elegir una forma de pieza aleatoria de la lista piece_shapes
                const randomIndex = Math.floor(Math.random() * piece_shapes.length);
                newPiece = piece_shapes[randomIndex];
            }

            return newPiece;
        }

        function drawPiece(piece, x, y) {
            // Dibujar la forma de la pieza en el canvas
            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        const xPos = (x + col) * cell_size_x;
                        const yPos = (y + row) * cell_size_y;
                        ctx.fillStyle = piece.color;
                        ctx.fillRect(xPos + border_width, yPos + border_width, cell_size_x - border_width * 2, cell_size_y - border_width * 2);
                    }
                }
            }
        }

        function erasePiece(piece, x, y) {
            // Borrar la forma de la pieza del canvas
            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        const xPos = (x + col) * cell_size_x;
                        const yPos = (y + row) * cell_size_y;
                        ctx.fillStyle = '#000';
                        ctx.fillRect(xPos, yPos, cell_size_x, cell_size_y);
                    }
                }
            }
        }

        function play_game() {

            ctx.clearRect(0, 0, canvas.width, canvas.height); // boarra tablero

            if (isPieceOverlap(currentPiece, currentX, currentY)) {
                placePieceOnBoard(currentPiece, currentX, currentY - 1);
                currentPiece = getRandomPiece(currentPiece);
                currentX = 0;
                currentY = 0;
            }
            draw_board();

            drawPiece(currentPiece, currentX, currentY);
            setTimeout(() => {
                currentY = currentY + 1;
                play_game();
            }, down_time);
        }

        play_game();

        function isPieceOverlap(piece, x, y) {
            // Comprobar cada celda de la pieza si se superpone con alguna celda del tablero
            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        const boardRow = y + row;
                        const boardCol = x + col;
                        // Comprobar si la celda de la pieza se superpone con una celda del tablero
                        if (boardRow < 0 || boardRow >= board_height || boardCol < 0 || boardCol >= board_width || board[boardRow][boardCol]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function placePieceOnBoard(piece, x, y) {
            // Copiar cada celda de la pieza al tablero
            console.log(board);
            for (let row = 0; row < piece.shape.length; row++) {
                for (let col = 0; col < piece.shape[row].length; col++) {
                    if (piece.shape[row][col]) {
                        const boardRow = y + row;
                        const boardCol = x + col;
                        board[boardRow][boardCol] = piece.color;
                    }
                }
            }
        }

        function rotatePiece(piece, direction) {
            const shape = piece.shape;
            const newShape = [];

            if (direction == 'right') {
                for (let i = 0; i < shape[0].length; i++) {
                    const newRow = [];
                    for (let j = shape.length - 1; j >= 0; j--) {
                        newRow.push(shape[j][i]);
                    }
                    newShape.push(newRow);
                }
            } else if (direction == 'left') {
                for (let i = shape[0].length - 1; i >= 0; i--) {
                    const newRow = [];
                    for (let j = 0; j < shape.length; j++) {
                        newRow.push(shape[j][i]);
                    }
                    newShape.push(newRow);
                }
            }

            return {
                shape: newShape,
                color: piece.color
            };
        }

        document.addEventListener('keydown', function (event) {
            switch (event.keyCode) {
                case 37: // Flecha izquierda
                    if (!isPieceOverlap(currentPiece, currentX - 1, currentY)) {
                        erasePiece(currentPiece, currentX, currentY);
                        currentX = currentX - 1;
                        drawPiece(currentPiece, currentX, currentY);
                    }
                    break;
                case 38: // Flecha arriba
                
                    break;
                case 39: // Flecha derecha
                    if (!isPieceOverlap(currentPiece, currentX + 1, currentY)) {
                        erasePiece(currentPiece, currentX, currentY);
                        currentX = currentX + 1;
                        drawPiece(currentPiece, currentX, currentY);
                    }
                    break;
                case 40: // Flecha abajo
                    if (!isPieceOverlap(currentPiece, currentX, currentY + 1)) {
                        erasePiece(currentPiece, currentX, currentY);
                        currentY = currentY + 1;
                        drawPiece(currentPiece, currentX, currentY);
                    }
                    break;
                case 90: // La tecla 'z' ha sido presionada
                    piece_temp = rotatePiece(currentPiece, 'left');
                    if (!isPieceOverlap(piece_temp, currentX, currentY)) {
                        erasePiece(currentPiece, currentX, currentY);
                        currentPiece = piece_temp;
                        drawPiece(currentPiece, currentX, currentY);
                    }
                    break;
                case 88: // La tecla 'x' ha sido presionada
                    piece_temp = rotatePiece(currentPiece, 'right');
                    if (!isPieceOverlap(piece_temp, currentX, currentY)) {
                        erasePiece(currentPiece, currentX, currentY);
                        currentPiece = piece_temp;
                        drawPiece(currentPiece, currentX, currentY);
                    }
                    break;
            }
        });

    </script>
</body>

</html>